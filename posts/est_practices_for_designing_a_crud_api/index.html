<meta name="viewport" content="width=device-width, initial-scale=1.0"></meta><link rel="stylesheet" type="text/css" href="../../style.css"><h1 id="bestpracticesfordesigningacrudapi">Best practices for designing a CRUD API</h1><h4 id="1172022kylemcveigh">11/7/2022 - Kyle McVeigh</h4><p><a href="../../">Go back to all articles</a></p><p>Designing an API is not a one-shape-fits all, but these are the some of the best practice I've found when designing a CRUD API for a web-app.</p><p>For this exercise, let's imagine you're building an API for a blog and we have an article table with the below shape </p><p>```</p><p>id: UUID </p><p>Title: string</p><p>body: text</p><p>author_id: UUID </p><p>status: enum (PUBLISHED, DRAFT, ARCHIVED) </p><p>created_at: timestamp</p><p>updated_at: timestamp </p><p>```</p><h2 id="read">Read</h2><p>Let's consider our fetch applications. There are three different actions I'll detail separately: Get, List, and Search </p><h3 id="get">Get</h3><h4 id="endpointgetapiarticledid">Endpoint: GET <code>/api/article/${id}/</code></h4><p>In the most basic form, we'll need to fetch a single article by ID. With a 200 it should return the entire object. In this example, we may want to include denormalized data about the author so the frontend doesn't have to do a second fetch for the author details. If an article can't be found with that ID a 404 should be returned.</p><h3 id="list">List</h3><h4 id="endpointgetapiarticleparametersoffsetnumber">Endpoint: GET <code>/api/article/</code> parameters: <code>{ offset?: number }</code></h4><p>This endpoint should return an array of article objects. If you're dealing with an excessively large table, I'd be mindful to include a limit in order to not stress your database or crash the user. I prefer to allow an optional parameter of an offset so the frontend can be in control of pagination. Be sure to create the array in a consistent and predictable ordering so the offset is deterministic. </p><h3 id="search">Search</h3><h4 id="endpointgetapiarticlesearchparameterstitlestring">Endpoint: GET <code>/api/article/search</code> parameters: <code>{ title?: string }</code></h4><p>Having a search endpoint is a common use case. This should return an array of found objects. I like it best when it is its own defined endpoint with a descriptive URL and there is search parameter object that takes all the fields that we'd like to search on. Search results should also have a limit and an offset.</p><h2 id="create">Create</h2><h4 id="endpointpostapiarticleparameterstitlestringbodystring">Endpoint: POST <code>/api/article/</code> parameters: <code>{ title?: string, body?: string, ... }</code></h4><p>The create should work with the minimum number of required parameters and not include an ID. The backend should handle the creation of the ID. The API should be resilient enough to parse strings to numbers, take dates in forgiving patterns, and handle other similar edge cases. A successful response should include a 200 and the entire newly created object, including the ID and timestamps. A failed case should be return 500 and include in the message why the failure occurred.</p><h2 id="update">Update</h2><p>I'm going to cover two common update patterns: updating the field of an object, and moving that object to a new state that would effect cascading objects</p><h3 id="updatefield">Update Field</h3><h4 id="endpointpatchapiarticledidparameterstitlestring">Endpoint: PATCH <code>/api/article/${id}/</code> parameters: <code>{ title?: string }</code></h4><p>When updating a single field or more than one field, the parameter should include a change object and only the fields included in the object should be updated. The fields not included on the change object should be left the same. On success a 200 should be returned along with the entire object. A 500 should be returned if the object was not updated and a 404 should be returned if the object could not be found.  </p><h3 id="triggerupdatedstate">Trigger Updated State</h3><h4 id="endpointpatchapiarticledidpublish">Endpoint: PATCH <code>/api/article/${id}/publish/</code></h4><p>Sometimes when a field is updated a service will kickoff that will update multiple fields and might even cascade and update multiple objects. In our scenario, imagine once an article gets a status called <code>publish</code> some code will be generated and automated emails will go out. Because this field has cascading effects, we want to be conscious of that and make a unique endpoint that will handle all cascading effects atomically. It is best that this field cannot be updated in the previous update endpoint in order to not have unintentional consequences. On success a 200 should return the entire updated object. 500 should be returned if the service could not run to completion and a 404 should be returned if the object could not be found.  </p><h2 id="delete">Delete</h2><h4 id="endpointdeleteapiarticledid">Endpoint: DELETE <code>/api/article/${id}/</code></h4><p>In this endpoint, there should be no other required parameters. The 200 response should include the deleted ID as confirmation and a deleted_at timestamp. A 500 should be returned if the object was not deleted and a 404 should be returned if the object could not be found. </p><p>I hope this has been helpful. Remember to aim in creating an API that is descriptive and resilient and to try to push logic down towards the database when possible. </p>